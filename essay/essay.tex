\include{settings}

\begin{document}	% начало документа

\include{titlepage}


% Содержание
%\tableofcontents
\newpage


\section*{Введение}

Сейчас мы живем в информационном обществе, и нас окружает огромный объем информации в том числе и графической. Наверно хоть раз вы отправляли картинку своему приятелю в социальной сети. Цифровое изображение при хранении занимает большие объемы памяти. Так растровое изображение размером 1024 на 1024 пикселов с глубиной цвета 24 бит занимает 3 Мб. Понятно, что хранение и передача изображений в таком виде является весьма трудоёмкой задачей. Поэтому задача представления изображений в компактной форме (сжатие данных) является весьма актуальной. При этом должны быть разработаны алгоритмы как для кодирования, так и для декодирования (восстановления) изображений. 
	
Первыми для архивации изображений стали применяться привычные алгоритмы. Те, что использовались и используются в системах резервного копирования, при создании дистрибутивов и т.п. Эти алгоритмы архивировали информацию без изменений. Однако основной тенденцией в последнее время стало использование новых классов изображений. Старые алгоритмы перестали удовлетворять требованиям, предъявляемым к архивации. Многие изображения практически не сжимались, хотя “на взгляд” обладали явной избыточностью. Это привело к созданию нового типа алгоритмов — сжимающих с потерей информации. Как правило, коэффициент архивации и, следовательно, степень потерь качества в них можно задавать. При этом достигается компромисс между размером и качеством изображений.
	
Идея, лежащая в основе всех алгоритмов сжатия с потерями, довольно проста: на первом этапе удалить несущественную информацию, а на втором этапе к оставшимся данным применить наиболее подходящий алгоритм сжатия без потерь. Основные сложности заключаются в выделении этой несущественной информации. Подходы здесь существенно различаются в зависимости от типа сжимаемых данных. Для звука чаще всего удаляют частоты, которые человек просто не способен воспринять, уменьшают частоту дискретизации, а также некоторые алгоритмы удаляют тихие звуки, следующие сразу за громкими, для видеоданных кодируют только движущиеся объекты, а незначительные изменения на неподвижных объектах просто отбрасывают. Методы выделения несущественной информации на изображениях будут подробно рассмотрены далее.

\section*{Методы сжатия}

\subsection*{Вейвлет сжатие}
%source: https://habrahabr.ru/post/251417/
Вейвлеты – математические функции, предназначенные для анализа частотных компонент данных. В задачах сжатия информации вейвлеты используются сравнительно недавно, тем не менее исследователям удалось достичь впечатляющих результатов.
В отличие от рассмотренных выше преобразований, вейвлеты не требуют предварительного разбиения исходного изображения на блоки, а могут применяться к изображению в целом. В данном разделе вейвлет сжатие будет пояснено на примере довольно простого вейвлета Хаара.
Для начала рассмотрим преобразование Хаара для одномерного сигнала. Пусть есть набор S из n значений, при преобразовании Хаара каждой паре элементов ставится в соответствие два числа: полусумма элементов и их полуразность. Важно отметить, что это преобразование обратимо: т.е. из пары чисел можно легко восстановить исходную пару. На рис \ref{pic:wavelt_example} показан пример одномерного преобразования Хаара:
\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.9]{pics/wavelet/example.png}
		\caption{Пример для одномерного пространства} 
		\label{pic:wavelt_example}
	\end{center}
\end{figure}
Видно, что сигнал распадается на две составляющее: приближенное значение исходного (с уменьшенным в два раза разрешением) и уточняющую информацию.
Двумерное преобразование Хаара – простая композиция одномерных преобразований. Если исходные данные представлены в виде матрицы, то сначала выполняется преобразование для каждой строки, а затем для полученных матриц выполняется преобразование для каждого столбца. На рис \ref{pic:wavelt_compression} показан пример двумерного преобразования Хаара.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/wavelet/compression.png}
		\caption{Процесс сжатия} 
		\label{pic:wavelt_compression}
	\end{center}
\end{figure}
Цвет пропорционален значению функции в точке (чем больше значение, тем темнее). В результате преобразования получается четыре матрицы: одна содержит аппроксимацию исходного изображения (с уменьшенной частотой дискретизации), а три остальных содержат уточняющую информацию.
Сжатие достигается путём удаления некоторых коэффициентов из уточняющих матриц. На рис \ref {pic:wavelt_uncompression} показан процесс восстановления и само восстановленное изображение после удаления из уточняющих матриц малых по модулю коэффициентов:

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/wavelet/uncompression.png}
		\caption{Процесс восстановления} 
		\label{pic:wavelt_uncompression}
	\end{center}
\end{figure}
Очевидно, что представление изображения с помощью вейвлетов позволяет добиваться эффективного сжатия, сохраняя при этом визуальное качество изображения. Существуют и другие вейвлеты, с помощью которых производится сжатие изображений.
\section*{Картинка}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/spbpu.jpg}
		\caption{название картинки} 
		\label{pic:pic_name} % название для ссылок внутри кода
	\end{center}
\end{figure}

\section*{Выводы}
Всё круто!!!

\end{document}
