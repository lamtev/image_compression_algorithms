\include{settings}

\begin{document}	% начало документа

\include{titlepage}


% Содержание
%\tableofcontents
\newpage


\section*{Введение}

Сейчас мы живем в информационном обществе, и нас окружает огромный объем информации в том числе и графической. Наверно хоть раз вы отправляли картинку своему приятелю в социальной сети. Цифровое изображение при хранении занимает большие объемы памяти. Так растровое изображение размером 1024 на 1024 пикселов с глубиной цвета 24 бит занимает 3 Мб. Понятно, что хранение и передача изображений в таком виде является весьма трудоёмкой задачей. Поэтому задача представления изображений в компактной форме (сжатие данных) является весьма актуальной. При этом должны быть разработаны алгоритмы как для кодирования, так и для декодирования (восстановления) изображений. 
	
Первыми для архивации изображений стали применяться привычные алгоритмы. Те, что использовались и используются в системах резервного копирования, при создании дистрибутивов и т.п. Эти алгоритмы архивировали информацию без изменений. Однако основной тенденцией в последнее время стало использование новых классов изображений. Старые алгоритмы перестали удовлетворять требованиям, предъявляемым к архивации. Многие изображения практически не сжимались, хотя “на взгляд” обладали явной избыточностью. Это привело к созданию нового типа алгоритмов — сжимающих с потерей информации. Как правило, коэффициент архивации и, следовательно, степень потерь качества в них можно задавать. При этом достигается компромисс между размером и качеством изображений.
	
Идея, лежащая в основе всех алгоритмов сжатия с потерями, довольно проста: на первом этапе удалить несущественную информацию, а на втором этапе к оставшимся данным применить наиболее подходящий алгоритм сжатия без потерь. Основные сложности заключаются в выделении этой несущественной информации. Подходы здесь существенно различаются в зависимости от типа сжимаемых данных. Для звука чаще всего удаляют частоты, которые человек просто не способен воспринять, уменьшают частоту дискретизации, а также некоторые алгоритмы удаляют тихие звуки, следующие сразу за громкими, для видеоданных кодируют только движущиеся объекты, а незначительные изменения на неподвижных объектах просто отбрасывают. Методы выделения несущественной информации на изображениях будут подробно рассмотрены далее.

\section*{Методы сжатия}

\subsection*{Цветовое пространство $YC_bC_r$ и цветовая субдискретезация}

% http://sernam.ru/cod_7.php
Известно, что органы зрения человека менее чувствительны к цвету предметов, чем к их яркости. В цветовом пространстве RGB все три компонента считаются одинаково важными, и они обычно сохраняются с одинаковым разрешением. Однако можно отобразить цветовое изображение более эффективно, отделив светимость от цветовой информации и представив ее с большим разрешением, чем цвет. Поэтому цветовое пространство YCbCr и его вариации является популярным методом эффективного представления цветных изображений. 

Буква Y в таких цветовых пространствах обозначает компоненту светимость, которая вычисляется как взвешенное усреднение компонент R, G и B по следующей формуле: 

\begin{displaymath}
	Y = k_rR + k_gG + k_bB
\end{displaymath}

$k$ - соответствующий весовой множитель.

стальные цветовые компоненты по существу определяются в виде разностей между светимостью Y и компонентами R, G и B: 

\begin{center}
	$C_b = B - Y$ 

	$C_r = C - Y$ 

	$C_g = G - Y$ 
\end{center}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.35]{pics/YCbCr/YCbCr_separation_h.jpg}
		\caption{Цветное изображение и его компоненты Y, $C_B$ и $C_R$} 
		\label{pic:YCbCr}
	\end{center}
\end{figure}

Число $C_b+C_r+C_g$ является постоянным, поэтому только две из трех хроматических компонент необходимо хранить, а третью вычислять на основе них. Чаще всего в качестве две искомых цветовых компонент используют Cb и Cr. 

Преобразование цветового пространства дает дополнительный эффект при сжатии цветных изображений. При этом алгоритмы сжатия сначала преобразуют исходное цветовое пространство из RGB в YCbCr, сжимают, а затем при восстановлении обратно преобразуют изображение в цветовое пространство RGB. Обычно преобразованное изображение подвергается цветовой субдескретизации для дальнейшего сжатия.

%https://ru.wikipedia.org/wiki/%D0%A6%D0%B2%D0%B5%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D1%83%D0%B1%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F
Цветовая субдискретизация — технология кодирования изображений со снижением цветового разрешения, при которой частота выборки цветоразностных сигналов может быть меньше частоты выборки яркостного сигнала. Основана на особенности человеческого зрения, выраженной большей чувствительностью к перепадам яркости, чем цвета. 

Структура дискретизации сигнала обозначается как соотношение между тремя частями X:a:b (например, 4:2:2), описывающими число выборок яркостных и цветоразностных сигналов. Этими частями являются:

\begin{itemize}
	
	\item X — частота дискретизации яркостного канала, выраженная коэффициентом базовой частоты (ширина макропикселя)
	
	\item a — число выборок цветоразностных сигналов (Cr, Cb) в горизонтальном направлении в первой строке
	
	\item b — число (дополнительных) выборок цветоразностных сигналов (Cr, Cb) во второй строке
	
\end{itemize}


\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.35]{pics/chroma_subsampling/chroma_subsampling_ratios.png}
		\caption{Форматы субдискретизации} 
		\label{pic:chroma_subsampling}
	\end{center}
\end{figure}

Цветовая субдискретизация является важным способом снижения скорости цифрового потока видеоданных (цифровое сжатие видеоинформации). Используется в системах аналогового и цифрового телевидения, цифровой видеозаписи и алгоритмах сжатия изображений, таких как JPEG.

\subsection*{Квантование и дискретезация}
%https://habrahabr.ru/post/251417/
С процессом квантования и дискретизации связано понятие визуальной избыточности. Значительная часть информации на изображении не может быть воспринята человеком: например, человек способен замечать незначительные перепады яркости, но гораздо менее чувствителен к цветности. Также, начиная с определённого момента, повышение точности дискретизации не влияет на визуальное восприятие изображения. Таким образом, некоторая часть информации может быть удалена без ухудшения визуального качества. Такую информацию называют визуально избыточной.
Самым простым способом удаления визуальной избыточности является уменьшение точности дискретизации, но на практике этот способ можно применять только для изображений с простой структурой, т.к. искажения, возникающие на сложных изображениях, слишком заметны см рис \ref{pic:discretization}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.9]{pics/quantization/discretization.png}
		\caption{Уменьшение точности дискретизации} 
		\label{pic:discretization}
	\end{center}
\end{figure}
Для удаления избыточной информации чаще уменьшают точность квантования, но нельзя уменьшать её бездумно, т.к. это приводит к резкому ухудшению качества изображения. Предположим, что изображение представлено в цветовом пространстве RGB, результаты кодирования этого изображения с пониженной точностью квантования представлены на рис \ref{pic:levels_of_quantization}.
\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.85]{pics/quantization/levels_of_quantization.png}
		\caption{Уменьшение точности квантования} 
		\label{pic:levels_of_quantization}
	\end{center}
\end{figure}
Внимательно изучив полученные изображения, можно заметить, что на сжатых изображениях возникают отчётливые ложные контуры, которые значительно ухудшают визуальное восприятие. Существуют методы, основанные на переносе ошибки квантования в следующий пиксел, позволяющие значительно уменьшить или даже совсем удалить эти контуры, но они приводят к зашумлению изображения и появлению зернистости. Перечисленные недостатки сильно ограничивают прямое применение квантования для сжатия изображений.
Большинство современных методов удаления визуально избыточной информации используют сведения об особенностях человеческого зрения. Всем известна различная чувствительность человеческого глаза к информации о цветности и яркости изображения. На рис \ref{pic:quantization} показано изображение в цветовом пространстве YIQ, закодированное с разной глубиной квантования цветоразностных сигналов IQ:
\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.75]{pics/quantization/quantization.png}
		\caption{Различная глубина квантования цветоразностных сигналов IQ} 
		\label{pic:quantization}
	\end{center}
\end{figure}
Как видно из рис \ref{pic:quantization}, глубина квантования цветоразностных сигналов может быть понижена с 256 до 32 уровней с минимальными визуальными изменениями. В то же время потери в I и Q составляющих весьма существенны. Несмотря на простоту описанных методов, в чистом виде они применяются редко, чаще всего они служат одним из шагов более эффективных алгоритмов.

\subsection*{Вейвлет сжатие}
%source: https://habrahabr.ru/post/251417/
Вейвлеты – математические функции, предназначенные для анализа частотных компонент данных. В задачах сжатия информации вейвлеты используются сравнительно недавно, тем не менее исследователям удалось достичь впечатляющих результатов.
В отличие от рассмотренных выше преобразований, вейвлеты не требуют предварительного разбиения исходного изображения на блоки, а могут применяться к изображению в целом. В данном разделе вейвлет сжатие будет пояснено на примере довольно простого вейвлета Хаара.
Для начала рассмотрим преобразование Хаара для одномерного сигнала. Пусть есть набор S из n значений, при преобразовании Хаара каждой паре элементов ставится в соответствие два числа: полусумма элементов и их полуразность. Важно отметить, что это преобразование обратимо: т.е. из пары чисел можно легко восстановить исходную пару. На рис \ref{pic:wavelet_example} показан пример одномерного преобразования Хаара:
\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.9]{pics/wavelet/example.png}
		\caption{Пример для одномерного пространства} 
		\label{pic:wavelet_example}
	\end{center}
\end{figure}
Видно, что сигнал распадается на две составляющее: приближенное значение исходного (с уменьшенным в два раза разрешением) и уточняющую информацию.
Двумерное преобразование Хаара – простая композиция одномерных преобразований. Если исходные данные представлены в виде матрицы, то сначала выполняется преобразование для каждой строки, а затем для полученных матриц выполняется преобразование для каждого столбца. На рис \ref{pic:wavelet_compression} показан пример двумерного преобразования Хаара.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/wavelet/compression.png}
		\caption{Процесс сжатия} 
		\label{pic:wavelet_compression}
	\end{center}
\end{figure}
Цвет пропорционален значению функции в точке (чем больше значение, тем темнее). В результате преобразования получается четыре матрицы: одна содержит аппроксимацию исходного изображения (с уменьшенной частотой дискретизации), а три остальных содержат уточняющую информацию.
Сжатие достигается путём удаления некоторых коэффициентов из уточняющих матриц. На рис \ref {pic:wavelet_uncompression} показан процесс восстановления и само восстановленное изображение после удаления из уточняющих матриц малых по модулю коэффициентов:

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/wavelet/uncompression.png}
		\caption{Процесс восстановления} 
		\label{pic:wavelet_uncompression}
	\end{center}
\end{figure}
Очевидно, что представление изображения с помощью вейвлетов позволяет добиваться эффективного сжатия, сохраняя при этом визуальное качество изображения. Существуют и другие вейвлеты, с помощью которых производится сжатие изображений.

\subsection*{RLE}
%source: https://habrahabr.ru/post/251417/
Все алгоритмы серии RLE основаны на очень простой идее: повторяющиеся группы элементов заменяются на пару (количество повторов, повторяющийся элемент). 

Рассмотрим этот алгоритм на примере последовательности бит. В этой последовательности будут чередовать группы нулей и единиц. Причём в группах зачастую будет более одного элемента. Тогда последовательности 11111 000000 11111111 00 будет соответствовать следующий набор чисел 5 6 8 2. Эти числа обозначают количество повторений (отсчёт начинается с единиц), но эти числа тоже необходимо кодировать. Будем считать, что число повторений лежит в пределах от 0 до 7 (т.е. нам хватит 3 бит для кодирования числа повторов). Тогда рассмотренная выше последовательность кодируется следующей последовательностью чисел 5 6 7 0 1 2. Легко подсчитать, что для кодирования исходной последовательности требуется 21 бит, а в сжатом по методу RLE виде эта последовательность занимает 18 бит.

Хоть этот алгоритм и очень прост, но эффективность его сравнительно низка. Более того, в некоторых случаях применение этого алгоритма приводит не к уменьшению, а к увеличению длины последовательности. Для примера рассмотрим следующую последовательность 111 0000 11111111 00. Соответствующая ей RL-последовательность выглядит так: 3 4 7 0 1 2. Длина исходной последовательности – 17 бит, длина сжатой последовательности – 18 бит.

Этот алгоритм наиболее эффективен для чёрно-белых изображений. Также он часто используется, как один из промежуточных этапов сжатия более сложных алгоритмов.

\subsection*{Алгоритм сжатия LZW}

Идея, лежащая в основе словарных алгоритмов, заключается в том, что происходит кодирование цепочек элементов исходной последовательности. При этом кодировании используется специальный словарь, который получается на основе исходной последовательности. 

Существует целое семейство словарных алгоритмов, но мы рассмотрим наиболее распространённый алгоритм LZW, названный в честь его разработчиков Лепеля, Зива и Уэлча. 

Словарь в этом алгоритме представляет собой таблицу, которая заполняется цепочками кодирования по мере работы алгоритма. При декодировании сжатого кода словарь восстанавливается автоматически, поэтому нет необходимости передавать словарь вместе с сжатым кодом. 

Рассмотрим пример сжатия алгоритмом. Будем сжимать строку кукушкакукушонкукупилакапюшон. Предположим, что словарь будет вмещать 32 позиции, а значит, каждый его код будет занимать 5 бит.

Сначала словарь инициализируется всеми одноэлементными цепочками, т.е. первые строки словаря представляют собой алфавит, в котором мы производим кодирование. Изначально словарь будете заполнен следующим образом:

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=1]{pics/LZW/dictionary.png}
		\caption{Начальный словарь} 
		\label{pic:lzw:dictionary}
	\end{center}
\end{figure}

При сжатии происходит поиск наиболее длинной цепочки уже записанной в словарь. Каждый раз, когда встречается цепочка, ещё не записанная в словарь, она добавляется туда, при этом выводится сжатый код, соответствующий уже записанной в словаре цепочки.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=1]{pics/LZW/result.png}
		\caption{Процесс и результат кодирования}
		\label{pic:lzw:result}
	\end{center}
\end{figure}

В теории на размер словаря не накладывается никаких ограничений, но на практике есть смысл этот размер ограничивать, так как со временем начинаются встречаться цепочки, которые больше в тексте не встречаются. Кроме того, при увеличении размеры таблицы вдвое мы должны выделять лишний бит для хранения сжатых кодов.
  

\section*{Картинка}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/spbpu.jpg}
		\caption{название картинки} 
		\label{pic:pic_name} % название для ссылок внутри кода
	\end{center}
\end{figure}

\section*{Выводы}
Всё круто!!!

\end{document}
